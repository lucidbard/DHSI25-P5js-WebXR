<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Digital Archaeology Mystery</title>
  <script src="https://unpkg.com/skulpt@0.11.1/dist/skulpt.min.js" onload="console.log('Skulpt loaded')"
    onerror="loadSkulptFallback()"></script>
  <script src="https://unpkg.com/skulpt@0.11.1/dist/skulpt-stdlib.js" onload="console.log('Skulpt stdlib loaded')"
    onerror="console.error('Failed to load Skulpt stdlib')"></script>
  <script>
    // Fallback function to load Skulpt from alternative CDN
    function loadSkulptFallback() {
      console.log('Trying fallback CDN for Skulpt...');
      const script1 = document.createElement('script');
      script1.src = 'https://cdnjs.cloudflare.com/ajax/libs/skulpt/0.11.1/skulpt.min.js';
      script1.onload = () => console.log('Skulpt loaded from fallback');
      script1.onerror = () => console.error('All CDNs failed for Skulpt');
      document.head.appendChild(script1);

      const script2 = document.createElement('script');
      script2.src = 'https://cdnjs.cloudflare.com/ajax/libs/skulpt/0.11.1/skulpt-stdlib.js';
      script2.onload = () => console.log('Skulpt stdlib loaded from fallback');
      document.head.appendChild(script2);
    }
  </script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Georgia', serif;
      background: linear-gradient(135deg, #2c1810, #4a3429);
      color: #f4f1e8;
      min-height: 100vh;
      line-height: 1.6;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
      padding: 20px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 15px;
      border: 2px solid #8b7355;
    }

    h1 {
      color: #d4af37;
      font-size: 2.5em;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    .subtitle {
      color: #c9b037;
      font-style: italic;
      font-size: 1.2em;
    }

    .progress-bar {
      width: 100%;
      height: 20px;
      background: #3a2c1f;
      border-radius: 10px;
      margin: 20px 0;
      border: 1px solid #8b7355;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #d4af37, #ffd700);
      transition: width 0.5s ease;
      width: 0%;
    }

    .game-area {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }

    .story-panel,
    .code-panel {
      background: rgba(0, 0, 0, 0.4);
      border-radius: 10px;
      padding: 20px;
      border: 1px solid #8b7355;
    }

    .story-panel h2,
    .code-panel h2 {
      color: #d4af37;
      margin-bottom: 15px;
      border-bottom: 2px solid #8b7355;
      padding-bottom: 10px;
    }

    .challenge-text {
      background: rgba(139, 115, 85, 0.2);
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
      border-left: 4px solid #d4af37;
    }    .code-editor {
      width: 100%;
      height: 200px;
      background: #ffffff;
      color: #000000;
      border: 2px solid #e1e4e8;
      border-radius: 8px;
      padding: 15px;
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 14px;
      resize: vertical;
      line-height: 1.4;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .jupyter-cell {
      background: #ffffff;
      border: 1px solid #cfcfcf;
      border-radius: 8px;
      margin: 20px 0;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .cell-header {
      background: #f7f7f7;
      border-bottom: 1px solid #e1e4e8;
      padding: 8px 15px;
      font-size: 12px;
      color: #586069;
      border-radius: 8px 8px 0 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .cell-number {
      font-weight: bold;
      color: #0969da;
    }

    .button-group {
      margin: 15px 0;
      display: flex;
      gap: 10px;
      justify-content: flex-start;
    }

    button {
      background: linear-gradient(135deg, #8b7355, #a0845c);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      transition: all 0.3s ease;
    }

    button:hover {
      background: linear-gradient(135deg, #a0845c, #b8956b);
      transform: translateY(-2px);
    }

    button:disabled {
      background: #666;
      cursor: not-allowed;
      transform: none;
    }

    .output {
      background: #0f1419;
      border: 1px solid #8b7355;
      border-radius: 5px;
      padding: 15px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      min-height: 100px;
      white-space: pre-wrap;
      margin-top: 15px;
      max-height: 200px;
      overflow-y: auto;
    }

    .success {
      color: #4ade80;
      background: rgba(74, 222, 128, 0.1);
    }

    .error {
      color: #f87171;
      background: rgba(248, 113, 113, 0.1);
    }

    .hint {
      background: rgba(59, 130, 246, 0.1);
      color: #60a5fa;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
      border-left: 4px solid #3b82f6;
    }

    .achievement {
      background: linear-gradient(135deg, #d4af37, #ffd700);
      color: #1a1a1a;
      padding: 15px;
      border-radius: 10px;
      margin: 15px 0;
      text-align: center;
      font-weight: bold;
      animation: glow 2s ease-in-out;
    }

    @keyframes glow {

      0%,
      100% {
        box-shadow: 0 0 5px rgba(212, 175, 55, 0.5);
      }

      50% {
        box-shadow: 0 0 20px rgba(212, 175, 55, 0.8);
      }
    }

    .data-sample {
      background: #2a2a2a;
      border: 1px solid #8b7355;
      border-radius: 5px;
      padding: 10px;
      margin: 10px 0;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      white-space: pre-wrap;
      overflow-x: auto;
    }

    @media (max-width: 768px) {
      .game-area {
        grid-template-columns: 1fr;
      }

      h1 {
        font-size: 2em;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>üèõÔ∏è Digital Archaeology Mystery</h1>
      <p class="subtitle">Code Your Way Through Ancient Secrets</p>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      <p>Stage <span id="currentStage">1</span> of <span id="totalStages">9</span></p>
    </div>

    <div class="game-area">
      <div class="story-panel">
        <h2>üìú Investigation Log</h2>
        <div id="storyContent"></div>
        <div class="challenge-text" id="challengeText"></div>
        <div id="dataDisplay"></div>
      </div>      <div class="code-panel">
        <h2>üíª Digital Analysis Tools</h2>
        
        <div class="jupyter-cell">
          <div class="cell-header">
            <span class="cell-number">In [1]:</span>
            <span>Python Code Cell</span>
          </div>
          <textarea id="codeEditor" class="code-editor" placeholder="# Write your Python code here...
# Press Run to execute"></textarea>
        </div>

        <div id="output" class="output"></div>
        
        <div class="button-group">
          <button onclick="runCode()">‚ñ∂Ô∏è Run</button>
          <button onclick="getHint()">üí° Hint</button>
          <button onclick="resetCode()">üîÑ Reset</button>
        </div>

        <div id="hintArea"></div>
      </div>
    </div>

    <div id="achievementArea"></div>
  </div>

  <script>    // Game state
    let currentStage = 1;
    const totalStages = 9;
    let stages = [];

    // Initialize Skulpt for Python execution
    function outf(text) {
      const output = document.getElementById("output");
      output.textContent += text;
    }

    function builtinRead(x) {
      if (Sk.builtinFiles === undefined || Sk.builtinFiles["files"][x] === undefined)
        throw "File not found: '" + x + "'";
      return Sk.builtinFiles["files"][x];
    }

    // Game stages definition
    function initializeStages() {
      stages = [
        {
          title: "The Mysterious Manuscript",          story: `Dr. Elena Rodriguez has discovered fragments of an ancient manuscript in the digital archives of the Alexandria Library. The fragments contain references to a lost civilization, but they're scattered and encoded. 

You've been called in as a digital archaeologist to help piece together this mystery using computational analysis.

<strong>üîç Python Concepts: Variables and Print Statements</strong>

In Python, we store information in <em>variables</em>. Think of variables as labeled boxes that hold data:
‚Ä¢ Text (strings) must be in quotes: <code>name = "Alexandria"</code>
‚Ä¢ Numbers don't need quotes: <code>count = 23</code>
‚Ä¢ Use <code>print()</code> to display information

Practice using variables and print statements with the manuscript data provided below.`,
          challenge: "Your task: Store the manuscript's catalog number and initial fragment count as variables, then display them using print statements.",
          data: `Manuscript ID: "MS-ALEX-2847"
Fragment Count: 23`,          starterCode: `# Store the manuscript data as variables and display them
# Manuscript ID: "MS-ALEX-2847"
# Fragment Count: 23

# Your code here:
`,
          solution: `catalog_number = "MS-ALEX-2847"
fragment_count = 23
print("Manuscript Catalog:", catalog_number)
print("Fragments Found:", fragment_count)`,
          hints: [
            "Variables store data. Use = to assign values to variable names.",
            "String variables need quotes: my_text = \"Hello\"",
            "Number variables don't need quotes: my_number = 42",
            "Use print() to display variable contents."
          ]
        },
        {
          title: "Analyzing Fragment Lengths",          story: `The manuscript fragments vary greatly in length. Some are mere words, others are complete sentences. Understanding the distribution of fragment sizes might reveal patterns about how the original text was structured.

<strong>üîç Python Concepts: Lists and For Loops</strong>

<em>Lists</em> store multiple values in a single variable:
‚Ä¢ Create lists with square brackets: <code>numbers = [1, 2, 3, 4]</code>
‚Ä¢ <em>For loops</em> let you process each item: <code>for item in my_list:</code>
‚Ä¢ <code>len()</code> returns how many items are in a list

Practice using lists and loops to analyze the fragment length data below.`,
          challenge: "Create a list of fragment lengths and calculate the total number of characters across all fragments.",
          data: `Fragment lengths (characters): [45, 23, 67, 12, 89, 34, 56, 78, 21, 43]`,
          starterCode: `# Create a list of fragment lengths and calculate totals
# Fragment lengths: [45, 23, 67, 12, 89, 34, 56, 78, 21, 43]

# Your code here:
`,
          solution: `fragment_lengths = [45, 23, 67, 12, 89, 34, 56, 78, 21, 43]
total_characters = 0
for length in fragment_lengths:
    total_characters = total_characters + length
print("Total characters:", total_characters)
print("Number of fragments:", len(fragment_lengths))`,
          hints: [
            "Lists store multiple values: my_list = [1, 2, 3]",
            "For loops iterate through each item: for item in my_list:",
            "len() function returns the length of a list",
            "Use += as shorthand for adding: total += value"
          ]
        },
        {
          title: "Decoding Fragment Languages",          story: `Dr. Rodriguez has identified that the fragments contain text in multiple ancient languages. Some fragments are in Latin, others in ancient Greek, and some in an unknown script. We need to categorize them to focus our translation efforts.

<strong>üîç Python Concepts: Conditional Statements (if/elif)</strong>

<em>Conditional statements</em> let your program make decisions:
‚Ä¢ <code>if</code> checks a condition: <code>if age >= 18:</code>
‚Ä¢ <code>elif</code> checks additional conditions: <code>elif age >= 13:</code>
‚Ä¢ <code>==</code> compares values (different from <code>=</code> which assigns)
‚Ä¢ Remember to indent code inside if/elif blocks!

Practice using conditional statements to categorize the language codes below.`,
          challenge: "Analyze the language codes and count how many fragments we have for each language type.",
          data: `Language codes: ["LAT", "GRK", "UNK", "LAT", "UNK", "LAT", "GRK", "LAT", "UNK", "GRK", "LAT", "UNK"]`,
          starterCode: `# Count language types using conditional statements
# Language codes: ["LAT", "GRK", "UNK", "LAT", "UNK", "LAT", "GRK", "LAT", "UNK", "GRK", "LAT", "UNK"]
# LAT = Latin, GRK = Greek, UNK = Unknown

# Your code here:
`,
          solution: `languages = ["LAT", "GRK", "UNK", "LAT", "UNK", "LAT", "GRK", "LAT", "UNK", "GRK", "LAT", "UNK"]
latin_count = 0
greek_count = 0
unknown_count = 0
for lang in languages:
    if lang == "LAT":
        latin_count = latin_count + 1
    elif lang == "GRK":
        greek_count = greek_count + 1
    elif lang == "UNK":
        unknown_count = unknown_count + 1
print("Latin fragments:", latin_count)
print("Greek fragments:", greek_count)
print("Unknown fragments:", unknown_count)`,
          hints: [
            "if statements check conditions: if variable == \"value\":",
            "elif handles additional conditions: elif variable == \"other\":",
            "Use == to compare values (not = which assigns)",
            "Remember to indent code inside if/elif blocks"
          ]
        },
        {
          title: "Dating Analysis",          story: `Carbon dating results have arrived! Each fragment has been assigned an estimated date range. By analyzing these dates, we might discover if all fragments belong to the same time period or if they span multiple eras.

<strong>üîç Python Concepts: Finding Min/Max and Range Checking</strong>

Finding the smallest and largest values in data:
‚Ä¢ Access list items by index: <code>my_list[0]</code> gets the first item
‚Ä¢ Compare numbers: <code>if date &lt; oldest_date:</code>
‚Ä¢ Combine conditions: <code>if date >= 100 and date &lt; 200:</code>
‚Ä¢ Update tracking variables inside loops

Practice finding minimum and maximum values in the dating data below.`,
          challenge: "Find the oldest and most recent fragments, and identify how many are from each century.",
          data: `Estimated dates (CE): [150, 230, 180, 340, 290, 160, 380, 200, 220, 310]`,
          starterCode: `# Analyze fragment dates to find oldest, newest, and century distribution
# Dates (CE): [150, 230, 180, 340, 290, 160, 380, 200, 220, 310]

# Your code here:
`,
          solution: `dates = [150, 230, 180, 340, 290, 160, 380, 200, 220, 310]
oldest_date = dates[0]
newest_date = dates[0]
for date in dates:
    if date < oldest_date:
        oldest_date = date
    if date > newest_date:
        newest_date = date
print("Oldest fragment:", oldest_date, "CE")
print("Newest fragment:", newest_date, "CE")
second_century = 0
third_century = 0
fourth_century = 0
for date in dates:
    if date >= 100 and date < 200:
        second_century = second_century + 1
    elif date >= 200 and date < 300:
        third_century = third_century + 1
    elif date >= 300 and date < 400:
        fourth_century = fourth_century + 1
print("2nd century fragments:", second_century)
print("3rd century fragments:", third_century)
print("4th century fragments:", fourth_century)`,
          hints: [
            "Access list items by index: my_list[0] gets the first item",
            "Use < and > to compare numbers: if number < 100:",
            "Combine conditions with 'and': if x >= 100 and x < 200:",
            "Update variables inside loops to track minimum/maximum values"
          ]
        }, {
          title: "Word Frequency Analysis",          story: `Dr. Rodriguez has translated several key fragments and noticed repeated words that might be significant. These recurring terms could be names, places, or important concepts that unlock the manuscript's meaning.

<strong>üîç Python Concepts: String Comparison and Finding Maximum Values</strong>

When analyzing text data, we often need to:
‚Ä¢ Compare strings using <code>==</code>: <code>if word == "temple":</code>
‚Ä¢ Count occurrences by checking each item in a list
‚Ä¢ Find the maximum value by comparing numbers
‚Ä¢ Convert numbers to strings for display: <code>str(count)</code>

Practice counting word frequencies and finding the most common word in the translated fragments below.`,
          challenge: "Count the frequency of important words across the translated fragments to identify the most significant terms.",
          data: `Key words found: ["temple", "gold", "alexandria", "temple", "scroll", "gold", "temple", "alexandria", "wisdom", "gold", "scroll", "temple"]`, 
          starterCode: `# Count word frequencies and find the most common word
# Words: ["temple", "gold", "alexandria", "temple", "scroll", "gold", "temple", "alexandria", "wisdom", "gold", "scroll", "temple"]

# Your code here:
`,
          solution: `words = ["temple", "gold", "alexandria", "temple", "scroll", "gold", "temple", "alexandria", "wisdom", "gold", "scroll", "temple"]
temple_count = 0
gold_count = 0
alexandria_count = 0
scroll_count = 0
wisdom_count = 0
for word in words:
    if word == "temple":
        temple_count = temple_count + 1
    elif word == "gold":
        gold_count = gold_count + 1
    elif word == "alexandria":
        alexandria_count = alexandria_count + 1
    elif word == "scroll":
        scroll_count = scroll_count + 1
    elif word == "wisdom":
        wisdom_count = wisdom_count + 1
print("Word frequencies:")
print("temple:", temple_count)
print("gold:", gold_count)
print("alexandria:", alexandria_count)
print("scroll:", scroll_count)
print("wisdom:", wisdom_count)
max_count = 0
most_frequent = ""
if temple_count > max_count:
    max_count = temple_count
    most_frequent = "temple"
if gold_count > max_count:
    max_count = gold_count
    most_frequent = "gold"
if alexandria_count > max_count:
    max_count = alexandria_count
    most_frequent = "alexandria"
print("Most frequent word:", most_frequent, "(" + str(max_count) + " times)")`,
          hints: [
            "String comparison works like numbers: if word == \"temple\":",
            "Track the maximum value by comparing with previous max",
            "str() converts numbers to strings for concatenation",
            "Use separate if statements (not elif) when you want to check all conditions"
          ]
        }, {
          title: "The Final Revelation",          story: `Your analysis has revealed something extraordinary! The fragments aren't just random texts - they're coordinates, directions, and clues to a hidden chamber beneath the Library of Alexandria. The repeated word "temple" refers to a secret repository of scrolls that survived the library's destruction.

<strong>üîç Python Concepts: String Methods and List Operations</strong>

Advanced string and list techniques for data processing:
‚Ä¢ <code>startswith()</code> checks if a string begins with specific characters: <code>if text.startswith("N"):</code>
‚Ä¢ <code>append()</code> adds items to a list: <code>my_list.append(item)</code>
‚Ä¢ <code>not in</code> checks if something is NOT in a list: <code>if item not in my_list:</code>
‚Ä¢ String concatenation with <code>+</code>: <code>"Hello " + "World"</code>

Practice using string methods to decode the coordinate fragments below.`,
          challenge: "Process the coordinate fragments to reveal the location of the hidden chamber.",
          data: `Coordinate clues: ["N31", "E29", "N31", "E30", "N31", "E29", "depth-15", "N31", "E30", "depth-15"]`, 
          starterCode: `# Process coordinate clues to find the hidden chamber location
# Coordinates: ["N31", "E29", "N31", "E30", "N31", "E29", "depth-15", "N31", "E30", "depth-15"]
# N = North latitude, E = East longitude, depth = meters below surface

# Your code here:
`,
          solution: `coordinates = ["N31", "E29", "N31", "E30", "N31", "E29", "depth-15", "N31", "E30", "depth-15"]
latitude_coords = []
longitude_coords = []
depth_coords = []
for coord in coordinates:
    if coord.startswith("N"):
        latitude_coords.append(coord)
    elif coord.startswith("E"):
        longitude_coords.append(coord)
    elif coord.startswith("depth"):
        depth_coords.append(coord)
print("Latitude references:")
for lat in latitude_coords:
    print(" ", lat)
print("Longitude references:")
for lon in longitude_coords:
    print(" ", lon)
print("Depth references:")
for depth in depth_coords:
    print(" ", depth)
unique_latitudes = []
unique_longitudes = []
for coord in latitude_coords:
    if coord not in unique_latitudes:
        unique_latitudes.append(coord)
for coord in longitude_coords:
    if coord not in unique_longitudes:
        unique_longitudes.append(coord)
print("\\nFinal coordinates:")
print("Latitude:", unique_latitudes[0])
print("Longitude:", unique_longitudes[0] + " to " + unique_longitudes[1])
print("Depth: 15 meters below surface")
print("\\nüèõÔ∏è DISCOVERY: Secret chamber located beneath Alexandria!")`,
          hints: [
            "startswith() checks if a string begins with specific characters",
            "append() adds items to a list: my_list.append(item)",
            "'not in' checks if an item is NOT in a list", "Access list items by index: my_list[0], my_list[1], etc."
          ]
        },
        {
          title: "AI Assistant Integration",          story: `The archaeological team has gained access to an advanced AI assistant to help analyze the remaining fragments. Dr. Rodriguez wants to understand how to effectively communicate with AI systems to accelerate the research process.

<strong>ü§ñ AI Concepts: Understanding AI Assistants</strong>

AI assistants like ChatGPT, Claude, or GitHub Copilot can help with:
‚Ä¢ Writing code based on descriptions: "Create a function that calculates average"
‚Ä¢ Explaining existing code: "What does this loop do?"
‚Ä¢ Debugging errors: "Why am I getting this error message?"
‚Ä¢ Optimizing solutions: "How can I make this code more efficient?"

AI assistants work best when you provide:
‚Ä¢ Clear, specific requests
‚Ä¢ Context about what you're trying to achieve
‚Ä¢ Examples of input and expected output
‚Ä¢ Information about any constraints or requirements

Practice AI-assisted thinking by clearly describing your analysis goals before coding.`,
          challenge: "Use AI-assisted thinking to analyze metadata about the manuscript fragments. Practice describing what you want in clear language before writing code.",
          data: `Fragment metadata: 
Fragment IDs: ["F001", "F002", "F003", "F004", "F005"]
Condition scores (1-10): [8, 3, 9, 6, 7]
Translation difficulty (1-5): [2, 5, 1, 4, 3]`,
          starterCode: `# Practice AI-assisted development:
# Step 1: Describe your goal clearly in comments
# Example: "I want to find which fragment has the best condition and which is easiest to translate"

# Step 2: Think about the data
fragment_ids = ["F001", "F002", "F003", "F004", "F005"]
condition_scores = [8, 3, 9, 6, 7]  # Higher = better condition
difficulty_scores = [2, 5, 1, 4, 3]  # Lower = easier to translate

# Your analysis code here:
`,
          solution: `fragment_ids = ["F001", "F002", "F003", "F004", "F005"]
condition_scores = [8, 3, 9, 6, 7]
difficulty_scores = [2, 5, 1, 4, 3]

# Find fragment with best condition (highest score)
best_condition_index = 0
for i in range(len(condition_scores)):
    if condition_scores[i] > condition_scores[best_condition_index]:
        best_condition_index = i

# Find fragment with easiest translation (lowest difficulty)
easiest_translation_index = 0
for i in range(len(difficulty_scores)):
    if difficulty_scores[i] < difficulty_scores[easiest_translation_index]:
        easiest_translation_index = i

print("Best condition fragment:", fragment_ids[best_condition_index])
print("Condition score:", condition_scores[best_condition_index])
print("Easiest to translate:", fragment_ids[easiest_translation_index])
print("Difficulty score:", difficulty_scores[easiest_translation_index])

# AI tip: Built-in functions can make this simpler!
print("\\nUsing AI-suggested built-ins:")
print("Best condition:", fragment_ids[condition_scores.index(max(condition_scores))])
print("Easiest translation:", fragment_ids[difficulty_scores.index(min(difficulty_scores))])`,
          hints: [
            "When working with AI: Describe your goal before coding",
            "Think about what 'best condition' means (highest number?)",
            "Think about what 'easiest translation' means (lowest difficulty?)",
            "AI assistants can suggest built-in functions like max(), min(), index()"
          ]
        },
        {
          title: "Effective Prompt Engineering",
          story: `Dr. Rodriguez needs to extract specific information from a large database of ancient texts. She's learning that the way you ask questions to an AI system greatly affects the quality of the response.

<strong>üéØ Prompt Engineering Principles:</strong>

<strong>Be Specific:</strong>
‚ùå "Help me with data analysis"
‚úÖ "Help me find the most common words in a list of ancient text fragments"

<strong>Provide Context:</strong>
‚ùå "Fix this code"
‚úÖ "This code should count languages but isn't working. I'm getting a NameError on line 3"

<strong>Give Examples:</strong>
‚ùå "Format the output nicely"
‚úÖ "Format like this: 'Fragment F001: Condition 8/10, Difficulty 2/5'"

<strong>Specify Constraints:</strong>
‚ùå "Make it better"
‚úÖ "Optimize for readability, avoid complex functions, explain each step"

<strong>Try this example:</strong>
<div class="data-sample">
# Good prompt: "Create code to process archaeological data where
# I have fragment IDs and need to pair them with analysis results,
# then display in a readable format showing fragment ID and status"

fragments = ["F001", "F002", "F003"]
analysis_complete = [True, False, True]

for i in range(len(fragments)):
    status = "Complete" if analysis_complete[i] else "Pending"
    print(f"Fragment {fragments[i]}: Analysis {status}")
</div>

Practice writing clear prompts for the task below.`,
          challenge: "Practice prompt engineering by describing exactly what analysis you want to perform on the manuscript data, then implement it.",
          data: `Research teams and their specialties:
Teams: ["Linguistics", "Dating", "Preservation", "Digital"]
Fragment assignments: [3, 2, 1, 4]
Completion rates: [0.8, 1.0, 0.5, 0.9]`,
          starterCode: `# PROMPT ENGINEERING PRACTICE:
# Write a clear prompt describing what you want to analyze:
# 
# Example good prompt:
# "I need to analyze research team performance. I have team names,
#  number of fragments assigned, and completion rates (0.0-1.0).
#  I want to find which team has the highest completion rate
#  and display all teams with their performance metrics."

# Your prompt (write it as a comment):
# 

# Now implement based on your prompt:
teams = ["Linguistics", "Dating", "Preservation", "Digital"]
assignments = [3, 2, 1, 4]
completion_rates = [0.8, 1.0, 0.5, 0.9]

# Your implementation here`,
          solution: `# PROMPT ENGINEERING PRACTICE:
# Good prompt: "Analyze research team performance by finding the team
# with highest completion rate, calculating total fragments processed,
# and displaying a performance report for each team showing name,
# assignments, completion rate, and estimated completed fragments."

teams = ["Linguistics", "Dating", "Preservation", "Digital"]
assignments = [3, 2, 1, 4]
completion_rates = [0.8, 1.0, 0.5, 0.9]

# Find team with highest completion rate
best_team_index = 0
for i in range(len(completion_rates)):
    if completion_rates[i] > completion_rates[best_team_index]:
        best_team_index = i

print("=== TEAM PERFORMANCE REPORT ===")
print()

# Display all team metrics
for i in range(len(teams)):
    completed_fragments = int(assignments[i] * completion_rates[i])
    percentage = completion_rates[i] * 100
    print(f"Team: {teams[i]}")
    print(f"  Assigned: {assignments[i]} fragments")
    print(f"  Completion Rate: {percentage:.0f}%")
    print(f"  Estimated Completed: {completed_fragments} fragments")
    print()

print(f"üèÜ Best Performance: {teams[best_team_index]} team")
print(f"   Completion Rate: {completion_rates[best_team_index] * 100:.0f}%")

# Calculate total project progress
total_assigned = sum(assignments)
total_completed = sum(assignments[i] * completion_rates[i] for i in range(len(teams)))
overall_progress = total_completed / total_assigned * 100
print(f"\\nüìä Overall Project Progress: {overall_progress:.1f}%")`,
          hints: [
            "Good prompts include: what data you have, what you want to find, how to display results",
            "Be specific about calculations: 'highest rate', 'total completed', etc.",
            "Think about what would be useful to display: percentages, rankings, summaries",
            "Consider edge cases and formatting in your prompt"
          ]
        },
        {
          title: "AI-Powered Code Review and Optimization",
          story: `The archaeological team has developed several analysis scripts, but they want to improve code quality and efficiency. Dr. Rodriguez is learning how to use AI assistants for code review, optimization, and best practices.

<strong>üîç AI Code Review Process:</strong>

<strong>1. Code Review Prompts:</strong>
‚Ä¢ "Review this code for bugs and improvements"
‚Ä¢ "Check this code for best practices and readability"
‚Ä¢ "Suggest optimizations for performance"
‚Ä¢ "Explain what this code does and identify potential issues"

<strong>2. Optimization Prompts:</strong>
‚Ä¢ "Make this code more efficient"
‚Ä¢ "Reduce the number of loops in this code"
‚Ä¢ "Use Python built-in functions to simplify this"
‚Ä¢ "Make this code more readable and maintainable"

<strong>3. Learning Prompts:</strong>
‚Ä¢ "Explain why this solution is better than my original"
‚Ä¢ "What Python concepts should I learn to improve this code?"
‚Ä¢ "Show me three different ways to solve this problem"

<strong>Example review process:</strong>
<div class="data-sample">
# Original code (works but could be better):
manuscripts = ["MS1", "MS2", "MS3", "MS4"]
priorities = [3, 1, 4, 2]
urgent_manuscripts = []
for i in range(len(manuscripts)):
    if priorities[i] >= 3:
        urgent_manuscripts.append(manuscripts[i])

# AI-suggested improvement:
manuscripts = ["MS1", "MS2", "MS3", "MS4"]
priorities = [3, 1, 4, 2]
urgent_manuscripts = [ms for ms, pri in zip(manuscripts, priorities) if pri >= 3]
print("Urgent manuscripts:", urgent_manuscripts)
</div>

Practice reviewing and optimizing code with AI assistance.`,
          challenge: "Review the inefficient code below and use AI thinking to identify improvements. Rewrite it using better practices.",
          data: `Fragment Processing Status:
Fragment IDs: ["F101", "F102", "F103", "F104", "F105", "F106"]
Processing times (hours): [2.5, 1.2, 4.8, 3.1, 0.9, 2.3]
Status: ["complete", "in-progress", "complete", "complete", "in-progress", "complete"]`,
          starterCode: `# INEFFICIENT CODE TO REVIEW:
# This code works but has several issues - identify and fix them

fragment_ids = ["F101", "F102", "F103", "F104", "F105", "F106"]
processing_times = [2.5, 1.2, 4.8, 3.1, 0.9, 2.3]
status = ["complete", "in-progress", "complete", "complete", "in-progress", "complete"]

# Find completed fragments
completed_fragments = []
completed_times = []
counter = 0
while counter < len(fragment_ids):
    if status[counter] == "complete":
        completed_fragments.append(fragment_ids[counter])
        completed_times.append(processing_times[counter])
    counter = counter + 1

# Calculate average time for completed fragments
total_time = 0
for time in completed_times:
    total_time = total_time + time
average_time = total_time / len(completed_times)

print("Completed fragments:", completed_fragments)
print("Average processing time:", average_time)

# Find fragment with longest processing time
longest_time = 0
longest_fragment = ""
for i in range(len(fragment_ids)):
    if processing_times[i] > longest_time:
        longest_time = processing_times[i]
        longest_fragment = fragment_ids[i]
print("Longest processing time:", longest_fragment, "took", longest_time, "hours")`,
          solution: `# OPTIMIZED CODE WITH AI IMPROVEMENTS:
# Key improvements: list comprehensions, built-in functions, better variable names

fragment_ids = ["F101", "F102", "F103", "F104", "F105", "F106"]
processing_times = [2.5, 1.2, 4.8, 3.1, 0.9, 2.3]
status = ["complete", "in-progress", "complete", "complete", "in-progress", "complete"]

# AI Improvement 1: Use list comprehensions and zip for cleaner filtering
completed_data = [(fid, time) for fid, time, stat in zip(fragment_ids, processing_times, status) if stat == "complete"]
completed_fragments, completed_times = zip(*completed_data) if completed_data else ([], [])

# AI Improvement 2: Use built-in functions for calculations
average_time = sum(completed_times) / len(completed_times) if completed_times else 0

print("=== PROCESSING ANALYSIS ===")
print(f"Completed fragments: {list(completed_fragments)}")
print(f"Average processing time: {average_time:.2f} hours")

# AI Improvement 3: Use max() with key parameter for finding extremes
longest_time_index = processing_times.index(max(processing_times))
longest_fragment = fragment_ids[longest_time_index]
longest_time = processing_times[longest_time_index]

print(f"Longest processing: {longest_fragment} ({longest_time} hours)")

# AI Improvement 4: Additional useful analysis
in_progress = [fid for fid, stat in zip(fragment_ids, status) if stat == "in-progress"]
completion_rate = len(completed_fragments) / len(fragment_ids) * 100

print(f"\\nIn progress: {in_progress}")
print(f"Completion rate: {completion_rate:.1f}%")

# AI Improvement 5: Better data structure (bonus)
print("\\n=== ALTERNATIVE: USING DICTIONARIES ===")
fragments_data = [
    {"id": fid, "time": time, "status": stat}
    for fid, time, stat in zip(fragment_ids, processing_times, status)
]

completed = [f for f in fragments_data if f["status"] == "complete"]
avg_time = sum(f["time"] for f in completed) / len(completed)
print(f"Dictionary approach - Average time: {avg_time:.2f} hours")`,
          hints: [
            "Look for: while loops that could be for loops, manual calculations that could use built-ins",
            "Consider: list comprehensions, zip(), max(), min(), sum() functions",
            "Think about: variable names, code readability, duplicated logic",
            "AI tip: Ask 'How can I make this more Pythonic?' for style improvements"
          ]
        }
      ];
    } function loadStage(stageNum) {
      const stage = stages[stageNum - 1];

      document.getElementById("currentStage").textContent = stageNum;
      document.getElementById("storyContent").innerHTML = `
                <h3>${stage.title}</h3>
                <p>${stage.story}</p>
            `;

      document.getElementById("challengeText").innerHTML = `
                <strong>Your Task:</strong> ${stage.challenge}
            `;

      if (stage.data) {
        document.getElementById("dataDisplay").innerHTML = `
<div class="data-sample">
<strong>Data to Analyze:</strong><br>
${stage.data.replace(/\n/g, '<br>')}
</div>
                `;
      }

      document.getElementById("codeEditor").value = stage.starterCode;
      document.getElementById("output").textContent = "";
      document.getElementById("hintArea").innerHTML = "";

      // Remove next stage button if present
      const existingNextBtn = document.getElementById('nextStageBtn');
      if (existingNextBtn) {
        existingNextBtn.remove();
      }

      // Update progress bar
      const progress = (stageNum / totalStages) * 100;
      document.getElementById("progressFill").style.width = progress + "%";
    }

    function runCode() {
      const code = document.getElementById("codeEditor").value;
      const output = document.getElementById("output");

      output.textContent = "";
      output.className = "output";

      // Check if Skulpt is loaded
      if (typeof Sk === 'undefined') {
        // Fallback mode - simulate some basic functionality
        output.className = "output error";
        output.textContent = "üîç Python interpreter loading... If this persists, the game is running in demo mode.\n\nYour code would execute:\n" + code;

        // Still check the solution structure for demo purposes
        setTimeout(() => {
          checkSolution(code);
        }, 1000);
        return;
      }

      Sk.pre = "output";
      Sk.configure({
        output: outf,
        read: builtinRead,
        execLimit: 10000
      });

      try {
        const promise = Sk.misceval.asyncToPromise(function () {
          return Sk.importMainWithBody("<stdin>", false, code, true);
        });

        promise.then(function (mod) {
          checkSolution(code);
        }, function (err) {
          output.className = "output error";
          output.textContent = generateErrorFeedback(err.toString());
        });
      } catch (err) {
        output.className = "output error";
        output.textContent = generateErrorFeedback(err.toString());
      }
    }

    function generateErrorFeedback(error) {
      const stage = stages[currentStage - 1];

      if (error.includes("SyntaxError")) {
        return `üîç Digital Analysis Error: Syntax issue detected!\n\nThe computer doesn't understand part of your code. Check for:\n‚Ä¢ Missing quotes around text\n‚Ä¢ Incorrect indentation\n‚Ä¢ Missing colons after if/for statements\n\nOriginal error: ${error}`;
      } else if (error.includes("NameError")) {
        return `üîç Archaeological Note: Variable not found!\n\nYou're trying to use a variable that hasn't been defined yet. Make sure you:\n‚Ä¢ Spell variable names correctly\n‚Ä¢ Define variables before using them\n\nOriginal error: ${error}`;
      } else if (error.includes("IndentationError")) {
        return `üîç Manuscript Format Error: Indentation issue!\n\nPython uses indentation (spaces) to group code. Make sure:\n‚Ä¢ Code inside if/for statements is indented\n‚Ä¢ Use consistent spacing (4 spaces recommended)\n\nOriginal error: ${error}`;
      } else {
        return `üîç Analysis Error: ${error}\n\nDon't worry! Debugging is part of the archaeological process. Check your code carefully and try again.`;
      }
    } function checkSolution(code) {
      const stage = stages[currentStage - 1];
      const output = document.getElementById("output");

      // Simple solution checking - in a real implementation, you'd want more sophisticated checking
      const requiredElements = getRequiredElements(currentStage);
      let passed = true;
      let feedback = [];

      for (let element of requiredElements) {
        if (!code.includes(element)) {
          passed = false;
          feedback.push(`Missing: ${element}`);
        }
      }

      if (passed) {
        output.className = "output success";
        showAchievement(stage.title);
        showNextStageButton();
      }
    }

    function showNextStageButton() {
      const buttonGroup = document.querySelector('.button-group');

      // Remove existing next button if present
      const existingNextBtn = document.getElementById('nextStageBtn');
      if (existingNextBtn) {
        existingNextBtn.remove();
      }

      if (currentStage < totalStages) {
        const nextButton = document.createElement('button');
        nextButton.id = 'nextStageBtn';
        nextButton.textContent = 'üèõÔ∏è Continue to Next Stage';
        nextButton.style.background = 'linear-gradient(135deg, #d4af37, #ffd700)';
        nextButton.style.color = '#1a1a1a';
        nextButton.style.fontWeight = 'bold';
        nextButton.onclick = () => {
          currentStage++;
          loadStage(currentStage);
          nextButton.remove();
        };
        buttonGroup.appendChild(nextButton);
      } else {
        const completeButton = document.createElement('button');
        completeButton.id = 'nextStageBtn';
        completeButton.textContent = 'üèõÔ∏è View Final Achievement';
        completeButton.style.background = 'linear-gradient(135deg, #d4af37, #ffd700)';
        completeButton.style.color = '#1a1a1a';
        completeButton.style.fontWeight = 'bold';
        completeButton.onclick = () => {
          showFinalAchievement();
          completeButton.remove();
        };
        buttonGroup.appendChild(completeButton);
      }
    } function getRequiredElements(stageNum) {
      const requirements = {
        1: ["catalog_number", "fragment_count", "print"],
        2: ["fragment_lengths", "for", "total_characters", "len"],
        3: ["languages", "if", "elif", "latin_count", "greek_count"],
        4: ["dates", "oldest_date", "newest_date", "second_century"],
        5: ["words", "temple_count", "most_frequent"],
        6: ["coordinates", "startswith", "append", "unique_latitudes"],
        7: ["fragment_ids", "condition_scores", "best_condition", "easiest_translation"],
        8: ["teams", "completion_rates", "best_team", "performance"],
        9: ["completed_fragments", "average_time", "longest_fragment", "optimization"]
      };
      return requirements[stageNum] || [];
    }

    function getHint() {
      const stage = stages[currentStage - 1];
      const hintArea = document.getElementById("hintArea");

      if (stage.hints && stage.hints.length > 0) {
        const randomHint = stage.hints[Math.floor(Math.random() * stage.hints.length)];
        hintArea.innerHTML = `<div class="hint">üí° <strong>Archaeological Insight:</strong> ${randomHint}</div>`;
      }
    }

    function resetCode() {
      const stage = stages[currentStage - 1];
      document.getElementById("codeEditor").value = stage.starterCode;
      document.getElementById("output").textContent = "";
      document.getElementById("hintArea").innerHTML = "";
    }

    function showAchievement(title) {
      const achievementArea = document.getElementById("achievementArea");
      achievementArea.innerHTML = `
                <div class="achievement">
                    üèÜ Achievement Unlocked: ${title} Complete!
                    <br>You've mastered another piece of the digital archaeology puzzle!
                </div>
            `;

      setTimeout(() => {
        achievementArea.innerHTML = "";
      }, 3000);
    } function showFinalAchievement() {
      const achievementArea = document.getElementById("achievementArea");
      achievementArea.innerHTML = `
                <div class="achievement">
                    üèõÔ∏è CONGRATULATIONS! üèõÔ∏è
                    <br><strong>Master Digital Archaeologist & AI Collaborator</strong>
                    <br>You've successfully decoded the ancient manuscript, discovered the hidden chamber beneath Alexandria, and mastered AI-assisted development!
                    <br><br>You've mastered:
                    <br>‚Ä¢ Variables (strings, numbers, lists)
                    <br>‚Ä¢ Conditional logic (if/elif statements)
                    <br>‚Ä¢ Loops (for statements)
                    <br>‚Ä¢ Data analysis techniques
                    <br>‚Ä¢ AI assistant collaboration
                    <br>‚Ä¢ Effective prompt engineering
                    <br>‚Ä¢ Code review and optimization
                    <br><br>Your computational skills and AI collaboration have unlocked both ancient history and modern development practices!
                    <br><br>ü§ñ Ready to work with AI assistants like ChatGPT, Claude, and GitHub Copilot to accelerate your coding journey!
                </div>
            `;
    }

    // Initialize the game
    document.addEventListener('DOMContentLoaded', function () {
      initializeStages();
      loadStage(1);

      // Add keyboard shortcut for running code
      document.getElementById('codeEditor').addEventListener('keydown', function (e) {
        if (e.ctrlKey && e.key === 'Enter') {
          e.preventDefault();
          runCode();
        }
      });

      // Add tab support in code editor
      document.getElementById('codeEditor').addEventListener('keydown', function (e) {
        if (e.key === 'Tab') {
          e.preventDefault();
          const start = this.selectionStart;
          const end = this.selectionEnd;
          this.value = this.value.substring(0, start) + "    " + this.value.substring(end);
          this.selectionStart = this.selectionEnd = start + 4;
        }
      });
    });
  </script>
</body>

</html>